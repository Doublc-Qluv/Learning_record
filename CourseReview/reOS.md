OS设计与实现时：
- 设计目标
- 机制与策略
- 相分离的原则
- 代码实现的表现
- 设计思想方法

# 进程
程序进行的一个实例
程序的一次执行
- job作业（批处理系统
- task任务（用户的角度
- process进程
## 进程的组成


- 系统进程、用户进程
- 进程概念
- 进程调度的概念
- 进程操作
- 进程间通信

操作系统概念
批处理系统和分时系统

用户模式以及内核模式：只有内核模式可以执行特殊权限
系统调用：软中断
实时OS

- 操作系统结构
  - 操作系统服务
  - 系统调用的概念：命令strace
    - 参数的传递
    - API和系统调用：内部有调用，对应一个调用、无关调用
    - 过程调用与系统调用：
  - 策略和机制的分离
  - 结构：
    - 微内核，精简代码，提高可靠性
- 进程
  - 进程和程序：
  - PCB
  - 进程的地址空间
  - 进程状态的迁移
  - 进程的切换
  - 进程的调度
  - 调度器：
    - 短程：cpu
    - 存储管理
    - 长程批处理器
    - 考虑cpu特性
      - IO密集还是CPU密集
  - 进程操作，进程创建：父子进程
  - 进程间通信
  - 共享内存：条件自己解决，使用信号量：生产者消费者
  - 消息传递：内部已经封装
  - 管道通信
- 线程
  - 共享进程的地址空间
  - 数据和任务
  - 多线程服务器
  - 用户线程和内核线程
    - 多对一一对一一对多
- 进程同步
- 关键区
- 抢占式内核以非抢占
- 自旋锁
- 信号量
  - 盲目等待
  - 进程迁移的方式
  - 解决互斥和同步
  - 使用不到导致死锁
  - 生产者消费者
  - 管程
  - 解决实际问题
    - 分析：有互斥有同步
    - 逻辑代码
    - 推理
- cpu调度
  - 进程以及生命周期规律
  - 条件：
  - 抢占式和非抢占式
  - 原则要考虑什么
  - 调度的算法
- 死锁
  - 的概念以及例子
  - 四个必要条件
  - 资源费配图要读懂
  - 处理死锁
    - 忽略
    - 预防
    - 避免
      - 银行家算法
    - 检测与恢复
- 主存
  - 进程空间之间隔离
  - 与内核隔离
  - 地址绑定
  - MMU
  - SWAP（交换
    - 标准：完整的换入换出
  - 存储的分配方案
    - 连续
    - 段式
    - 分页
    - 地址映射
  - TLB
  - 页表的拓展
  - 存储的共享
  - 分级页表
  - hash页表
  - 反向页表
- 虚拟存储
  - 请求调页
  - 缺页
  - 写时复制（做性能优化
  - 页面切换
    - LRU
    - 二次机会淘汰
  - 按行遍历
  - 按页遍历（高缺页
- 大容量存储
  - 交换分区的管理
  - 磁盘调度
- 文件系统的接口
  - 包含的属性
  - 操作
    - 文件锁
  - 访问方法
    - 顺序访问
    - 直接访问
  - 路径
  - 连结
  - 文件系统的挂载
  - 目录的权限
  - 系统实现
    - 功能的实现 
- IO
  - port bus ……
  - 驱动
  - 轮训、中断、
  - 字符设备和块设备
  - 阻塞非阻塞
- 防护
  - 原则
  - 保护宇
  - 访问控制矩阵的三种方式
- 安全
  - 缓冲区溢出的攻击

```c
struct semaphore{
  int value;
  pointer_PCB queue;
}
```
```c
semaphore s;
```
PV操作